/*
 * Copyright 2003-2005 (c) Live Media Pty Ltd. <argot@einet.com.au> 
 *
 * This software is licensed under the Argot Public License 
 * which may be found in the file LICENSE distributed 
 * with this software.
 *
 * More information about this license can be found at
 * http://www.einet.com.au/License
 * 
 * The Developer of this software is Live Media Pty Ltd,
 * PO Box 4591, Melbourne 3001, Australia.  The license is subject 
 * to the law of Victoria, Australia, and subject to exclusive 
 * jurisdiction of the Victorian courts.
 */

 
 /*
 * The meta dictionary.
 *
 * This is the core dictionary used to describe data types.
 *
 */
(library.list [

/*
 * The empty type is used for tagging information.  It is a 
 * basic type that is empty.
 * EMPTY_ID 1
 */

(library.entry 
	(library.definition meta.name:"empty" meta.version:"1.3")	
	(meta.fixed_width uint16:0
		[ (meta.fixed_width.attribute.size uint16:0) ]))


/*
 * The u8 type is unsigned 8bit big endian.
 * UINT8_ID 2
 */

(library.entry
	(library.definition meta.name:"uint8" meta.version:"1.3")
	(meta.fixed_width uint16:8 
		[ (meta.fixed_width.attribute.size uint16:8)
	  	  (meta.fixed_width.attribute.integer)
	  	  (meta.fixed_width.attribute.unsigned)
	  	  (meta.fixed_width.attribute.bigendian) ] ))

/*
 * The u16 type is unsigned 16bit big endian.
 * UINT16_ID 3
 */
 
(library.entry
	(library.definition meta.name:"uint16" meta.version:"1.3")
	(meta.fixed_width uint16:16
	[ (meta.fixed_width.attribute.size uint16:16)
	  (meta.fixed_width.attribute.integer)
	  (meta.fixed_width.attribute.unsigned)
	  (meta.fixed_width.attribute.bigendian) ] ))

/*
 * meta.id is used to identify a type.
 * META_ID_ID 4
 */
 
(library.entry 
	(library.definition meta.name:"meta.id" meta.version:"1.3")
	(meta.reference #uint16))


/*
 * A map is used to map an abstract data type to a
 * concrete data type.  Two U16 values are used to specify
 * the data types in the dictionary being defined.
 * META_MAP_ID 5
 */
			
(library.entry 
	(library.definition meta.name:"meta.abstract_map" meta.version:"1.3") 
	(meta.sequence [
		(meta.tag u8utf8:"id" (meta.reference #meta.id))
	]))
	
/*
 * A type defined as abstract has an empty definition.
 * META_ABSTRACT_ID 6
 */
	
(library.entry
	(library.definition meta.name:"meta.abstract" meta.version:"1.3")
	(meta.sequence [
		(meta.array 
			(meta.reference #uint8)
			(meta.reference #meta.abstract_map))]))


/*
 * u8utf8 is a simple ASCII encoded string of maxiumum length 255
 * characters.
 * u8utf8_ID 7
 */

(library.entry
	(library.definition meta.name:"u8utf8" meta.version:"1.3") 
	(meta.encoding 
		(meta.array 
			(meta.reference #uint8) 
			(meta.reference #uint8))
		u8utf8:"UTF-8")) 

/*
 *  meta.name defines all type names.  Its a simple u8utf8 string.
 *  META_NAME_ID 8
 */

(library.entry
	(library.definition meta.name:"meta.name_part" meta.version:"1.3")
	(meta.reference #u8utf8))

(library.entry
	(library.definition meta.name:"meta.name" meta.version:"1.3")
	(meta.array 
		(meta.reference #uint8)
		(meta.reference #meta.name_part)))

(library.entry 
	(library.definition meta.name:"meta.version" meta.version:"1.3")
	(meta.sequence [
		(meta.tag u8utf8:"major" (meta.reference #uint8))
		(meta.tag u8utf8:"minor" (meta.reference #uint8))
	]))


(library.entry
	(library.definition meta.name:"meta.definition" meta.version:"1.3")
	(meta.abstract [
		(meta.abstract_map #meta.fixed_width)
		(meta.abstract_map #meta.abstract)
		(meta.abstract_map #meta.abstract_map)
		(meta.abstract_map #meta.expression)
		(meta.abstract_map #meta.identity)
	]))

(library.entry
	(library.definition meta.name:"meta.identity" meta.version:"1.3")
	(meta.sequence [
	]))


/*
 *  An expression is an abstract type. It allows different
 *  expressions to be used to define data types.  New expressions
 *  can be added to expand specification language.
 *  META_EXPRESSION_ID 9
 */


(library.entry 
	(library.definition meta.name:"meta.expression" meta.version:"1.3")
	(meta.abstract [
		(meta.abstract_map #meta.reference)
		(meta.abstract_map #meta.tag)
		(meta.abstract_map #meta.sequence)
		(meta.abstract_map #meta.array)
		(meta.abstract_map #meta.envelop)
		(meta.abstract_map #meta.encoding)
	]))

/*
 *  A reference delcares a usage of another data tpye
 *  in the system.  The name data type is used to define
 *  a description of usage of that data type.
 *  META_REFERENCE_ID 10
 */

(library.entry 
	(library.definition meta.name:"meta.reference" meta.version:"1.3")
	(meta.sequence [(meta.reference #meta.id)]))
		
/*
 *  A tag is used to label a part of a sequence.  It is only
 *  used as meta data.
 *  META_TAG_ID 11
 */
 
(library.entry
	(library.definition meta.name:"meta.tag" meta.version:"1.3")
	(meta.sequence [
		(meta.tag u8utf8:"name" 
			(meta.reference #u8utf8))
		(meta.tag u8utf8:"data" 
			(meta.reference #meta.expression))]))

		
/*
 *  A sequence defines a set of expressions which
 *  are executed in order.  In the most normal case,
 *  it defines an ordered set of types in a data buffer.
 *  META_SEQUENCE_ID 12
 */

(library.entry 
	(library.definition meta.name:"meta.sequence" meta.version:"1.3")
	(meta.array 
		(meta.reference #uint8)
		(meta.reference #meta.expression)))

		
/*
 *  An Array is used to define any collection of data with
 *  a size and a type.
 *  META_ARRAY_ID 13
 */
		
(library.entry
	(library.definition meta.name:"meta.array" meta.version:"1.3")
	(meta.sequence [
		(meta.tag u8utf8:"size" (meta.reference #meta.expression))
		(meta.tag u8utf8:"data" (meta.reference #meta.expression))]))

/*
 *  An envelop is used to wrap any data.  This allows a group of data
 *  to be read without actually being decoded.  The decoding can take
 *  place when required.
 *  META_ENVELOP_ID 14
 */

(library.entry
	(library.definition meta.name:"meta.envelop" meta.version:"1.3")
	(meta.sequence [
		(meta.tag u8utf8:"size" (meta.reference #meta.expression))
		(meta.tag u8utf8:"type" (meta.reference #meta.expression)) ]))


/*
 *  Encoding specifies the data encoding used on a character
 *  string.  The data expression must return an array that
 *  can have encoding applied.
 *  META_ENCODING_ID 15
 */

(library.entry 
	(library.definition meta.name:"meta.encoding" meta.version:"1.3")
	(meta.sequence [
		(meta.tag u8utf8:"data" (meta.reference #meta.expression))
		(meta.tag u8utf8:"encoding" (meta.reference #u8utf8))]))


/*
 * Basic types are defined by a width and set of flags.
 * META_FIXED_WIDTH_ID 16 
 */

(library.entry 
	(library.definition meta.name:"meta.fixed_width" meta.version:"1.3") 
	(meta.sequence [
		(meta.tag u8utf8:"size" (meta.reference #uint16))
	   	(meta.tag u8utf8:"flags" 
			(meta.array 
				(meta.reference #uint8)
				(meta.reference #meta.fixed_width.attribute)))]))

/* META_BASIC_ATTRIBUTE_ID 17 */

(library.entry
	(library.definition meta.name:"meta.fixed_width.attribute" meta.version:"1.3")
	(meta.abstract [
		(meta.abstract_map #meta.fixed_width.attribute.size)
		(meta.abstract_map #meta.fixed_width.attribute.integer)
		(meta.abstract_map #meta.fixed_width.attribute.unsigned)
		(meta.abstract_map #meta.fixed_width.attribute.bigendian)
	]))


/* META_BASIC_ATTRIBUTE_SIZE_ID 18 */

(library.entry
	(library.definition meta.name:"meta.fixed_width.attribute.size" meta.version:"1.3")
	(meta.sequence [
		(meta.tag u8utf8:"size" (meta.reference #uint16))
	]))


/* META_BASIC_ATTRIBUTE_INTEGER_ID 19 */

(library.entry
	(library.definition meta.name:"meta.fixed_width.attribute.integer" meta.version:"1.3")
	(meta.sequence []))


/* META_BASIC_ATTRIBUTE_UNSIGNED_ID 20 */

(library.entry 
	(library.definition meta.name:"meta.fixed_width.attribute.unsigned" meta.version:"1.3") 
	(meta.sequence []))


/* META_BASIC_ATTRIBUTE_BIGENDIAN_ID 22 */

(library.entry 
	(library.definition meta.name:"meta.fixed_width.attribute.bigendian" meta.version:"1.3")
	(meta.sequence[]))


(library.entry
	(library.definition meta.name:"dictionary.name" meta.version:"1.3")
	(meta.sequence [
		(meta.tag u8utf8:"name" (meta.reference #meta.name))
	]))

(library.entry
	(library.definition meta.name:"dictionary.definition" meta.version:"1.3")
	(meta.sequence [
		(meta.tag u8utf8:"id" (meta.reference #meta.id))
		(meta.tag u8utf8:"version" (meta.reference #meta.version))
	]))

(library.entry
	(library.definition meta.name:"dictionary.relation" meta.version:"1.3")
	(meta.sequence [
		(meta.tag u8utf8:"id" (meta.reference #meta.id))
	]))

(library.entry
	(library.definition meta.name:"dictionary.location" meta.version:"1.3")
	(meta.abstract [
		(meta.abstract_map #dictionary.name)
		(meta.abstract_map #dictionary.definition)
		(meta.abstract_map #dictionary.relation)
	]))


/* DEFINITION_ENVELOP 39 */

(library.entry
	(library.definition meta.name:"meta.definition.envelop" meta.version:"1.3")
	(meta.envelop 
		(meta.reference #uint16)
		(meta.reference #meta.definition)))



/* DEFINITION_ENTRY_ID 40 */

(library.entry 
	(library.definition meta.name:"dictionary.entry" meta.version:"1.3")
	(meta.sequence [
		(meta.tag u8utf8:"id" (meta.reference #meta.id))
		(meta.tag u8utf8:"location" (meta.reference #dictionary.location))
		(meta.tag u8utf8:"definition" (meta.reference #meta.definition.envelop))]))


/* DEFINITION_ENTRY_LIST_ID 41 */

(library.entry
	(library.definition meta.name:"dictionary.entry.list" meta.version:"1.3")
	(meta.array 
		(meta.reference #uint16)
		(meta.reference #dictionary.entry )))

])

